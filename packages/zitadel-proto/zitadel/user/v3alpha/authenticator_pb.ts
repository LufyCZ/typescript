// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file zitadel/user/v3alpha/authenticator.proto (package zitadel.user.v3alpha, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Struct, Timestamp } from "@bufbuild/protobuf";
import { Details } from "../../object/v2beta/object_pb.js";

/**
 * @generated from enum zitadel.user.v3alpha.AuthNKeyType
 */
export enum AuthNKeyType {
  /**
   * @generated from enum value: AUTHN_KEY_TYPE_UNSPECIFIED = 0;
   */
  AUTHN_KEY_TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: AUTHN_KEY_TYPE_JSON = 1;
   */
  AUTHN_KEY_TYPE_JSON = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(AuthNKeyType)
proto3.util.setEnumType(AuthNKeyType, "zitadel.user.v3alpha.AuthNKeyType", [
  { no: 0, name: "AUTHN_KEY_TYPE_UNSPECIFIED" },
  { no: 1, name: "AUTHN_KEY_TYPE_JSON" },
]);

/**
 * @generated from enum zitadel.user.v3alpha.WebAuthNAuthenticatorType
 */
export enum WebAuthNAuthenticatorType {
  /**
   * @generated from enum value: WEB_AUTH_N_AUTHENTICATOR_UNSPECIFIED = 0;
   */
  WEB_AUTH_N_AUTHENTICATOR_UNSPECIFIED = 0,

  /**
   * @generated from enum value: WEB_AUTH_N_AUTHENTICATOR_PLATFORM = 1;
   */
  WEB_AUTH_N_AUTHENTICATOR_PLATFORM = 1,

  /**
   * @generated from enum value: WEB_AUTH_N_AUTHENTICATOR_CROSS_PLATFORM = 2;
   */
  WEB_AUTH_N_AUTHENTICATOR_CROSS_PLATFORM = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(WebAuthNAuthenticatorType)
proto3.util.setEnumType(WebAuthNAuthenticatorType, "zitadel.user.v3alpha.WebAuthNAuthenticatorType", [
  { no: 0, name: "WEB_AUTH_N_AUTHENTICATOR_UNSPECIFIED" },
  { no: 1, name: "WEB_AUTH_N_AUTHENTICATOR_PLATFORM" },
  { no: 2, name: "WEB_AUTH_N_AUTHENTICATOR_CROSS_PLATFORM" },
]);

/**
 * @generated from message zitadel.user.v3alpha.Authenticators
 */
export class Authenticators extends Message<Authenticators> {
  /**
   * All of the user's usernames, which will be used for identification during authentication.
   *
   * @generated from field: repeated zitadel.user.v3alpha.Username usernames = 1;
   */
  usernames: Username[] = [];

  /**
   * If the user has set a password, the time it was last changed will be returned.
   *
   * @generated from field: zitadel.user.v3alpha.Password password = 2;
   */
  password?: Password;

  /**
   * Meta information about the user's WebAuthN authenticators.
   *
   * @generated from field: repeated zitadel.user.v3alpha.WebAuthN web_auth_n = 3;
   */
  webAuthN: WebAuthN[] = [];

  /**
   * A list of the user's time-based one-time-password (TOTP) authenticators,
   * incl. the name for identification.
   *
   * @generated from field: repeated zitadel.user.v3alpha.TOTP totps = 4;
   */
  totps: TOTP[] = [];

  /**
   * A list of the user's one-time-password (OTP) SMS authenticators.
   *
   * @generated from field: repeated zitadel.user.v3alpha.OTPSMS otp_sms = 5;
   */
  otpSms: OTPSMS[] = [];

  /**
   * A list of the user's one-time-password (OTP) Email authenticators.
   *
   * @generated from field: repeated zitadel.user.v3alpha.OTPEmail otp_email = 6;
   */
  otpEmail: OTPEmail[] = [];

  /**
   * A list of the user's authentication keys. They can be used to authenticate e.g. by JWT Profile.
   *
   * @generated from field: repeated zitadel.user.v3alpha.AuthenticationKey authentication_keys = 7;
   */
  authenticationKeys: AuthenticationKey[] = [];

  /**
   * A list of the user's linked identity providers (IDPs).
   *
   * @generated from field: repeated zitadel.user.v3alpha.IdentityProvider identity_providers = 8;
   */
  identityProviders: IdentityProvider[] = [];

  constructor(data?: PartialMessage<Authenticators>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.Authenticators";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "usernames", kind: "message", T: Username, repeated: true },
    { no: 2, name: "password", kind: "message", T: Password },
    { no: 3, name: "web_auth_n", kind: "message", T: WebAuthN, repeated: true },
    { no: 4, name: "totps", kind: "message", T: TOTP, repeated: true },
    { no: 5, name: "otp_sms", kind: "message", T: OTPSMS, repeated: true },
    { no: 6, name: "otp_email", kind: "message", T: OTPEmail, repeated: true },
    { no: 7, name: "authentication_keys", kind: "message", T: AuthenticationKey, repeated: true },
    { no: 8, name: "identity_providers", kind: "message", T: IdentityProvider, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Authenticators {
    return new Authenticators().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Authenticators {
    return new Authenticators().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Authenticators {
    return new Authenticators().fromJsonString(jsonString, options);
  }

  static equals(a: Authenticators | PlainMessage<Authenticators> | undefined, b: Authenticators | PlainMessage<Authenticators> | undefined): boolean {
    return proto3.util.equals(Authenticators, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.Username
 */
export class Username extends Message<Username> {
  /**
   * unique identifier of the username.
   *
   * @generated from field: string username_id = 1;
   */
  usernameId = "";

  /**
   * The user's unique username. It is used for identification during authentication.
   *
   * @generated from field: string username = 2;
   */
  username = "";

  /**
   * By default usernames must be unique across all organizations in an instance.
   * This option allow to restrict the uniqueness to the user's own organization.
   * As a result, this username can only be used if the authentication is limited
   * to the corresponding organization.
   *
   * This can be useful if you provide multiple usernames for a single user, where one
   * if specific to your organization, e.g.:
   * - gigi-giraffe@zitadel.com (unique across organizations)
   * - gigi-giraffe (unique only inside the ZITADEL organization)
   *
   * @generated from field: bool is_organization_specific = 3;
   */
  isOrganizationSpecific = false;

  constructor(data?: PartialMessage<Username>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.Username";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "username_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "is_organization_specific", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Username {
    return new Username().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Username {
    return new Username().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Username {
    return new Username().fromJsonString(jsonString, options);
  }

  static equals(a: Username | PlainMessage<Username> | undefined, b: Username | PlainMessage<Username> | undefined): boolean {
    return proto3.util.equals(Username, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.SetUsername
 */
export class SetUsername extends Message<SetUsername> {
  /**
   * Set the user's username. This will be used for identification during authentication.
   *
   * @generated from field: string username = 1;
   */
  username = "";

  /**
   * By default username must be unique across all organizations in an instance.
   * This option allow to restrict the uniqueness to the user's own organization.
   * As a result, this username can only be used if the authentication is limited
   * to the corresponding organization.
   *
   * This can be useful if you provide multiple usernames for a single user, where one
   * if specific to your organization, e.g.:
   * - gigi-giraffe@zitadel.com (unique across organizations)
   * - gigi-giraffe (unique only inside the ZITADEL organization)
   *
   * @generated from field: bool is_organization_specific = 2;
   */
  isOrganizationSpecific = false;

  constructor(data?: PartialMessage<SetUsername>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.SetUsername";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "is_organization_specific", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetUsername {
    return new SetUsername().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetUsername {
    return new SetUsername().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetUsername {
    return new SetUsername().fromJsonString(jsonString, options);
  }

  static equals(a: SetUsername | PlainMessage<SetUsername> | undefined, b: SetUsername | PlainMessage<SetUsername> | undefined): boolean {
    return proto3.util.equals(SetUsername, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.Password
 */
export class Password extends Message<Password> {
  /**
   * States the time the password was last changed.
   *
   * @generated from field: google.protobuf.Timestamp last_changed = 1;
   */
  lastChanged?: Timestamp;

  constructor(data?: PartialMessage<Password>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.Password";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "last_changed", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Password {
    return new Password().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Password {
    return new Password().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Password {
    return new Password().fromJsonString(jsonString, options);
  }

  static equals(a: Password | PlainMessage<Password> | undefined, b: Password | PlainMessage<Password> | undefined): boolean {
    return proto3.util.equals(Password, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.WebAuthN
 */
export class WebAuthN extends Message<WebAuthN> {
  /**
   * unique identifier of the WebAuthN authenticator.
   *
   * @generated from field: string web_auth_n_id = 1;
   */
  webAuthNId = "";

  /**
   * Name of the WebAuthN authenticator. This is used for easier identification.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * State whether the WebAuthN registration has been completed.
   *
   * @generated from field: bool is_verified = 3;
   */
  isVerified = false;

  /**
   * States if the user has been verified during the registration. Authentication with this device
   * will be considered as multi factor authentication (MFA) without the need to check a password
   * (typically known as Passkeys).
   * Without user verification it will be a second factor authentication (2FA), typically done
   * after a password check.
   *
   * More on WebAuthN User Verification: https://www.w3.org/TR/webauthn/#user-verification
   *
   * @generated from field: bool user_verified = 4;
   */
  userVerified = false;

  constructor(data?: PartialMessage<WebAuthN>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.WebAuthN";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "web_auth_n_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "is_verified", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "user_verified", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebAuthN {
    return new WebAuthN().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebAuthN {
    return new WebAuthN().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebAuthN {
    return new WebAuthN().fromJsonString(jsonString, options);
  }

  static equals(a: WebAuthN | PlainMessage<WebAuthN> | undefined, b: WebAuthN | PlainMessage<WebAuthN> | undefined): boolean {
    return proto3.util.equals(WebAuthN, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.OTPSMS
 */
export class OTPSMS extends Message<OTPSMS> {
  /**
   * unique identifier of the one-time-password (OTP) SMS authenticator.
   *
   * @generated from field: string otp_sms_id = 1;
   */
  otpSmsId = "";

  /**
   * The phone number used for the OTP SMS authenticator.
   *
   * @generated from field: string phone = 2;
   */
  phone = "";

  /**
   * State whether the OTP SMS registration has been completed.
   *
   * @generated from field: bool is_verified = 3;
   */
  isVerified = false;

  constructor(data?: PartialMessage<OTPSMS>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.OTPSMS";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "otp_sms_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "phone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "is_verified", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OTPSMS {
    return new OTPSMS().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OTPSMS {
    return new OTPSMS().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OTPSMS {
    return new OTPSMS().fromJsonString(jsonString, options);
  }

  static equals(a: OTPSMS | PlainMessage<OTPSMS> | undefined, b: OTPSMS | PlainMessage<OTPSMS> | undefined): boolean {
    return proto3.util.equals(OTPSMS, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.OTPEmail
 */
export class OTPEmail extends Message<OTPEmail> {
  /**
   * unique identifier of the one-time-password (OTP) Email authenticator.
   *
   * @generated from field: string otp_email_id = 1;
   */
  otpEmailId = "";

  /**
   * The email address used for the OTP Email authenticator.
   *
   * @generated from field: string address = 2;
   */
  address = "";

  /**
   * State whether the OTP Email registration has been completed.
   *
   * @generated from field: bool is_verified = 3;
   */
  isVerified = false;

  constructor(data?: PartialMessage<OTPEmail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.OTPEmail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "otp_email_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "is_verified", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OTPEmail {
    return new OTPEmail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OTPEmail {
    return new OTPEmail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OTPEmail {
    return new OTPEmail().fromJsonString(jsonString, options);
  }

  static equals(a: OTPEmail | PlainMessage<OTPEmail> | undefined, b: OTPEmail | PlainMessage<OTPEmail> | undefined): boolean {
    return proto3.util.equals(OTPEmail, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.TOTP
 */
export class TOTP extends Message<TOTP> {
  /**
   * unique identifier of the time-based one-time-password (TOTP) authenticator.
   *
   * @generated from field: string totp_id = 1;
   */
  totpId = "";

  /**
   * The name provided during registration. This is used for easier identification.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * State whether the TOTP registration has been completed.
   *
   * @generated from field: bool is_verified = 3;
   */
  isVerified = false;

  constructor(data?: PartialMessage<TOTP>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.TOTP";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "totp_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "is_verified", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TOTP {
    return new TOTP().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TOTP {
    return new TOTP().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TOTP {
    return new TOTP().fromJsonString(jsonString, options);
  }

  static equals(a: TOTP | PlainMessage<TOTP> | undefined, b: TOTP | PlainMessage<TOTP> | undefined): boolean {
    return proto3.util.equals(TOTP, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.AuthenticationKey
 */
export class AuthenticationKey extends Message<AuthenticationKey> {
  /**
   * ID is the read-only unique identifier of the authentication key.
   *
   * @generated from field: string authentication_key_id = 1;
   */
  authenticationKeyId = "";

  /**
   * @generated from field: zitadel.object.v2beta.Details details = 2;
   */
  details?: Details;

  /**
   * the file type of the key
   *
   * @generated from field: zitadel.user.v3alpha.AuthNKeyType type = 3;
   */
  type = AuthNKeyType.AUTHN_KEY_TYPE_UNSPECIFIED;

  /**
   * After the expiration date, the key will no longer be usable for authentication.
   *
   * @generated from field: google.protobuf.Timestamp expiration_date = 4;
   */
  expirationDate?: Timestamp;

  constructor(data?: PartialMessage<AuthenticationKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.AuthenticationKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authentication_key_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "details", kind: "message", T: Details },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(AuthNKeyType) },
    { no: 4, name: "expiration_date", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthenticationKey {
    return new AuthenticationKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthenticationKey {
    return new AuthenticationKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthenticationKey {
    return new AuthenticationKey().fromJsonString(jsonString, options);
  }

  static equals(a: AuthenticationKey | PlainMessage<AuthenticationKey> | undefined, b: AuthenticationKey | PlainMessage<AuthenticationKey> | undefined): boolean {
    return proto3.util.equals(AuthenticationKey, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.IdentityProvider
 */
export class IdentityProvider extends Message<IdentityProvider> {
  /**
   * IDP ID is the read-only unique identifier of the identity provider in ZITADEL.
   *
   * @generated from field: string idp_id = 1;
   */
  idpId = "";

  /**
   * IDP name is the name of the identity provider in ZITADEL.
   *
   * @generated from field: string idp_name = 3;
   */
  idpName = "";

  /**
   * The user ID represents the ID provided by the identity provider.
   * This ID is used to link the user in ZITADEL with the identity provider.
   *
   * @generated from field: string user_id = 4;
   */
  userId = "";

  /**
   * The username represents the username provided by the identity provider.
   *
   * @generated from field: string username = 5;
   */
  username = "";

  constructor(data?: PartialMessage<IdentityProvider>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.IdentityProvider";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "idp_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "idp_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentityProvider {
    return new IdentityProvider().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentityProvider {
    return new IdentityProvider().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentityProvider {
    return new IdentityProvider().fromJsonString(jsonString, options);
  }

  static equals(a: IdentityProvider | PlainMessage<IdentityProvider> | undefined, b: IdentityProvider | PlainMessage<IdentityProvider> | undefined): boolean {
    return proto3.util.equals(IdentityProvider, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.SetAuthenticators
 */
export class SetAuthenticators extends Message<SetAuthenticators> {
  /**
   * @generated from field: repeated zitadel.user.v3alpha.SetUsername usernames = 1;
   */
  usernames: SetUsername[] = [];

  /**
   * @generated from field: zitadel.user.v3alpha.SetPassword password = 2;
   */
  password?: SetPassword;

  constructor(data?: PartialMessage<SetAuthenticators>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.SetAuthenticators";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "usernames", kind: "message", T: SetUsername, repeated: true },
    { no: 2, name: "password", kind: "message", T: SetPassword },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetAuthenticators {
    return new SetAuthenticators().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetAuthenticators {
    return new SetAuthenticators().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetAuthenticators {
    return new SetAuthenticators().fromJsonString(jsonString, options);
  }

  static equals(a: SetAuthenticators | PlainMessage<SetAuthenticators> | undefined, b: SetAuthenticators | PlainMessage<SetAuthenticators> | undefined): boolean {
    return proto3.util.equals(SetAuthenticators, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.SetPassword
 */
export class SetPassword extends Message<SetPassword> {
  /**
   * @generated from oneof zitadel.user.v3alpha.SetPassword.type
   */
  type: {
    /**
     * Provide the plain text password. ZITADEL will take care to store it in a secure way (hash).
     *
     * @generated from field: string password = 1;
     */
    value: string;
    case: "password";
  } | {
    /**
     * Encoded hash of a password in Modular Crypt Format:
     * https://zitadel.com/docs/concepts/architecture/secrets#hashed-secrets.
     *
     * @generated from field: string hash = 2;
     */
    value: string;
    case: "hash";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Provide if the user needs to change the password on the next use.
   *
   * @generated from field: bool change_required = 3;
   */
  changeRequired = false;

  constructor(data?: PartialMessage<SetPassword>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.SetPassword";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "type" },
    { no: 2, name: "hash", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "type" },
    { no: 3, name: "change_required", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetPassword {
    return new SetPassword().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetPassword {
    return new SetPassword().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetPassword {
    return new SetPassword().fromJsonString(jsonString, options);
  }

  static equals(a: SetPassword | PlainMessage<SetPassword> | undefined, b: SetPassword | PlainMessage<SetPassword> | undefined): boolean {
    return proto3.util.equals(SetPassword, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.SendPasswordResetEmail
 */
export class SendPasswordResetEmail extends Message<SendPasswordResetEmail> {
  /**
   * Optionally set a url_template, which will be used in the password reset mail
   * sent by ZITADEL to guide the user to your password change page.
   * If no template is set, the default ZITADEL url will be used.
   *
   * @generated from field: optional string url_template = 2;
   */
  urlTemplate?: string;

  constructor(data?: PartialMessage<SendPasswordResetEmail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.SendPasswordResetEmail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "url_template", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendPasswordResetEmail {
    return new SendPasswordResetEmail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendPasswordResetEmail {
    return new SendPasswordResetEmail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendPasswordResetEmail {
    return new SendPasswordResetEmail().fromJsonString(jsonString, options);
  }

  static equals(a: SendPasswordResetEmail | PlainMessage<SendPasswordResetEmail> | undefined, b: SendPasswordResetEmail | PlainMessage<SendPasswordResetEmail> | undefined): boolean {
    return proto3.util.equals(SendPasswordResetEmail, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.SendPasswordResetSMS
 */
export class SendPasswordResetSMS extends Message<SendPasswordResetSMS> {
  constructor(data?: PartialMessage<SendPasswordResetSMS>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.SendPasswordResetSMS";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendPasswordResetSMS {
    return new SendPasswordResetSMS().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendPasswordResetSMS {
    return new SendPasswordResetSMS().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendPasswordResetSMS {
    return new SendPasswordResetSMS().fromJsonString(jsonString, options);
  }

  static equals(a: SendPasswordResetSMS | PlainMessage<SendPasswordResetSMS> | undefined, b: SendPasswordResetSMS | PlainMessage<SendPasswordResetSMS> | undefined): boolean {
    return proto3.util.equals(SendPasswordResetSMS, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.ReturnPasswordResetCode
 */
export class ReturnPasswordResetCode extends Message<ReturnPasswordResetCode> {
  constructor(data?: PartialMessage<ReturnPasswordResetCode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.ReturnPasswordResetCode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReturnPasswordResetCode {
    return new ReturnPasswordResetCode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReturnPasswordResetCode {
    return new ReturnPasswordResetCode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReturnPasswordResetCode {
    return new ReturnPasswordResetCode().fromJsonString(jsonString, options);
  }

  static equals(a: ReturnPasswordResetCode | PlainMessage<ReturnPasswordResetCode> | undefined, b: ReturnPasswordResetCode | PlainMessage<ReturnPasswordResetCode> | undefined): boolean {
    return proto3.util.equals(ReturnPasswordResetCode, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.AuthenticatorRegistrationCode
 */
export class AuthenticatorRegistrationCode extends Message<AuthenticatorRegistrationCode> {
  /**
   * ID to the one time code generated by ZITADEL.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * one time code generated by ZITADEL.
   *
   * @generated from field: string code = 2;
   */
  code = "";

  constructor(data?: PartialMessage<AuthenticatorRegistrationCode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.AuthenticatorRegistrationCode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthenticatorRegistrationCode {
    return new AuthenticatorRegistrationCode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthenticatorRegistrationCode {
    return new AuthenticatorRegistrationCode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthenticatorRegistrationCode {
    return new AuthenticatorRegistrationCode().fromJsonString(jsonString, options);
  }

  static equals(a: AuthenticatorRegistrationCode | PlainMessage<AuthenticatorRegistrationCode> | undefined, b: AuthenticatorRegistrationCode | PlainMessage<AuthenticatorRegistrationCode> | undefined): boolean {
    return proto3.util.equals(AuthenticatorRegistrationCode, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.SendWebAuthNRegistrationLink
 */
export class SendWebAuthNRegistrationLink extends Message<SendWebAuthNRegistrationLink> {
  /**
   * Optionally set a url_template, which will be used in the mail sent by ZITADEL
   * to guide the user to your passkey registration page.
   * If no template is set, the default ZITADEL url will be used.
   *
   * @generated from field: optional string url_template = 1;
   */
  urlTemplate?: string;

  constructor(data?: PartialMessage<SendWebAuthNRegistrationLink>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.SendWebAuthNRegistrationLink";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url_template", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendWebAuthNRegistrationLink {
    return new SendWebAuthNRegistrationLink().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendWebAuthNRegistrationLink {
    return new SendWebAuthNRegistrationLink().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendWebAuthNRegistrationLink {
    return new SendWebAuthNRegistrationLink().fromJsonString(jsonString, options);
  }

  static equals(a: SendWebAuthNRegistrationLink | PlainMessage<SendWebAuthNRegistrationLink> | undefined, b: SendWebAuthNRegistrationLink | PlainMessage<SendWebAuthNRegistrationLink> | undefined): boolean {
    return proto3.util.equals(SendWebAuthNRegistrationLink, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.ReturnWebAuthNRegistrationCode
 */
export class ReturnWebAuthNRegistrationCode extends Message<ReturnWebAuthNRegistrationCode> {
  constructor(data?: PartialMessage<ReturnWebAuthNRegistrationCode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.ReturnWebAuthNRegistrationCode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReturnWebAuthNRegistrationCode {
    return new ReturnWebAuthNRegistrationCode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReturnWebAuthNRegistrationCode {
    return new ReturnWebAuthNRegistrationCode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReturnWebAuthNRegistrationCode {
    return new ReturnWebAuthNRegistrationCode().fromJsonString(jsonString, options);
  }

  static equals(a: ReturnWebAuthNRegistrationCode | PlainMessage<ReturnWebAuthNRegistrationCode> | undefined, b: ReturnWebAuthNRegistrationCode | PlainMessage<ReturnWebAuthNRegistrationCode> | undefined): boolean {
    return proto3.util.equals(ReturnWebAuthNRegistrationCode, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.RedirectURLs
 */
export class RedirectURLs extends Message<RedirectURLs> {
  /**
   * URL to which the user will be redirected after a successful login.
   *
   * @generated from field: string success_url = 1;
   */
  successUrl = "";

  /**
   * URL to which the user will be redirected after a failed login.
   *
   * @generated from field: string failure_url = 2;
   */
  failureUrl = "";

  constructor(data?: PartialMessage<RedirectURLs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.RedirectURLs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "failure_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RedirectURLs {
    return new RedirectURLs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RedirectURLs {
    return new RedirectURLs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RedirectURLs {
    return new RedirectURLs().fromJsonString(jsonString, options);
  }

  static equals(a: RedirectURLs | PlainMessage<RedirectURLs> | undefined, b: RedirectURLs | PlainMessage<RedirectURLs> | undefined): boolean {
    return proto3.util.equals(RedirectURLs, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.LDAPCredentials
 */
export class LDAPCredentials extends Message<LDAPCredentials> {
  /**
   * Username used to login through LDAP.
   *
   * @generated from field: string username = 1;
   */
  username = "";

  /**
   * Password used to login through LDAP.
   *
   * @generated from field: string password = 2;
   */
  password = "";

  constructor(data?: PartialMessage<LDAPCredentials>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.LDAPCredentials";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LDAPCredentials {
    return new LDAPCredentials().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LDAPCredentials {
    return new LDAPCredentials().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LDAPCredentials {
    return new LDAPCredentials().fromJsonString(jsonString, options);
  }

  static equals(a: LDAPCredentials | PlainMessage<LDAPCredentials> | undefined, b: LDAPCredentials | PlainMessage<LDAPCredentials> | undefined): boolean {
    return proto3.util.equals(LDAPCredentials, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.IdentityProviderIntent
 */
export class IdentityProviderIntent extends Message<IdentityProviderIntent> {
  /**
   * ID of the identity provider (IDP) intent.
   *
   * @generated from field: string idp_intent_id = 1;
   */
  idpIntentId = "";

  /**
   * Token of the identity provider (IDP) intent.
   *
   * @generated from field: string idp_intent_token = 2;
   */
  idpIntentToken = "";

  /**
   * If the user was already federated and linked to a ZITADEL user, it's id will be returned.
   *
   * @generated from field: optional string user_id = 3;
   */
  userId?: string;

  constructor(data?: PartialMessage<IdentityProviderIntent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.IdentityProviderIntent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "idp_intent_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "idp_intent_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentityProviderIntent {
    return new IdentityProviderIntent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentityProviderIntent {
    return new IdentityProviderIntent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentityProviderIntent {
    return new IdentityProviderIntent().fromJsonString(jsonString, options);
  }

  static equals(a: IdentityProviderIntent | PlainMessage<IdentityProviderIntent> | undefined, b: IdentityProviderIntent | PlainMessage<IdentityProviderIntent> | undefined): boolean {
    return proto3.util.equals(IdentityProviderIntent, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.IDPInformation
 */
export class IDPInformation extends Message<IDPInformation> {
  /**
   * ID of the identity provider.
   *
   * @generated from field: string idp_id = 1;
   */
  idpId = "";

  /**
   * ID of the user provided by the identity provider.
   *
   * @generated from field: string user_id = 2;
   */
  userId = "";

  /**
   * Username of the user provided by the identity provider.
   *
   * @generated from field: string user_name = 3;
   */
  userName = "";

  /**
   * Complete information returned by the identity provider.
   *
   * @generated from field: google.protobuf.Struct raw_information = 4;
   */
  rawInformation?: Struct;

  /**
   * additional access information returned by the identity provider.
   *
   * @generated from oneof zitadel.user.v3alpha.IDPInformation.access
   */
  access: {
    /**
     * OAuth/OIDC access (and id_token) returned by the identity provider.
     *
     * @generated from field: zitadel.user.v3alpha.IDPOAuthAccessInformation oauth = 5;
     */
    value: IDPOAuthAccessInformation;
    case: "oauth";
  } | {
    /**
     * LDAP entity attributes returned by the identity provider
     *
     * @generated from field: zitadel.user.v3alpha.IDPLDAPAccessInformation ldap = 6;
     */
    value: IDPLDAPAccessInformation;
    case: "ldap";
  } | {
    /**
     * SAMLResponse returned by the identity provider
     *
     * @generated from field: zitadel.user.v3alpha.IDPSAMLAccessInformation saml = 7;
     */
    value: IDPSAMLAccessInformation;
    case: "saml";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<IDPInformation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.IDPInformation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "idp_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "user_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "raw_information", kind: "message", T: Struct },
    { no: 5, name: "oauth", kind: "message", T: IDPOAuthAccessInformation, oneof: "access" },
    { no: 6, name: "ldap", kind: "message", T: IDPLDAPAccessInformation, oneof: "access" },
    { no: 7, name: "saml", kind: "message", T: IDPSAMLAccessInformation, oneof: "access" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IDPInformation {
    return new IDPInformation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IDPInformation {
    return new IDPInformation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IDPInformation {
    return new IDPInformation().fromJsonString(jsonString, options);
  }

  static equals(a: IDPInformation | PlainMessage<IDPInformation> | undefined, b: IDPInformation | PlainMessage<IDPInformation> | undefined): boolean {
    return proto3.util.equals(IDPInformation, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.IDPOAuthAccessInformation
 */
export class IDPOAuthAccessInformation extends Message<IDPOAuthAccessInformation> {
  /**
   * The access_token returned by the identity provider.
   *
   * @generated from field: string access_token = 1;
   */
  accessToken = "";

  /**
   * In case the provider returned an id_token.
   *
   * @generated from field: optional string id_token = 2;
   */
  idToken?: string;

  constructor(data?: PartialMessage<IDPOAuthAccessInformation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.IDPOAuthAccessInformation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "access_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id_token", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IDPOAuthAccessInformation {
    return new IDPOAuthAccessInformation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IDPOAuthAccessInformation {
    return new IDPOAuthAccessInformation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IDPOAuthAccessInformation {
    return new IDPOAuthAccessInformation().fromJsonString(jsonString, options);
  }

  static equals(a: IDPOAuthAccessInformation | PlainMessage<IDPOAuthAccessInformation> | undefined, b: IDPOAuthAccessInformation | PlainMessage<IDPOAuthAccessInformation> | undefined): boolean {
    return proto3.util.equals(IDPOAuthAccessInformation, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.IDPLDAPAccessInformation
 */
export class IDPLDAPAccessInformation extends Message<IDPLDAPAccessInformation> {
  /**
   * The attributes of the user returned by the identity provider.
   *
   * @generated from field: google.protobuf.Struct attributes = 1;
   */
  attributes?: Struct;

  constructor(data?: PartialMessage<IDPLDAPAccessInformation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.IDPLDAPAccessInformation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "attributes", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IDPLDAPAccessInformation {
    return new IDPLDAPAccessInformation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IDPLDAPAccessInformation {
    return new IDPLDAPAccessInformation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IDPLDAPAccessInformation {
    return new IDPLDAPAccessInformation().fromJsonString(jsonString, options);
  }

  static equals(a: IDPLDAPAccessInformation | PlainMessage<IDPLDAPAccessInformation> | undefined, b: IDPLDAPAccessInformation | PlainMessage<IDPLDAPAccessInformation> | undefined): boolean {
    return proto3.util.equals(IDPLDAPAccessInformation, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.IDPSAMLAccessInformation
 */
export class IDPSAMLAccessInformation extends Message<IDPSAMLAccessInformation> {
  /**
   * The SAML assertion returned by the identity provider.
   *
   * @generated from field: bytes assertion = 1;
   */
  assertion = new Uint8Array(0);

  constructor(data?: PartialMessage<IDPSAMLAccessInformation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.IDPSAMLAccessInformation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "assertion", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IDPSAMLAccessInformation {
    return new IDPSAMLAccessInformation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IDPSAMLAccessInformation {
    return new IDPSAMLAccessInformation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IDPSAMLAccessInformation {
    return new IDPSAMLAccessInformation().fromJsonString(jsonString, options);
  }

  static equals(a: IDPSAMLAccessInformation | PlainMessage<IDPSAMLAccessInformation> | undefined, b: IDPSAMLAccessInformation | PlainMessage<IDPSAMLAccessInformation> | undefined): boolean {
    return proto3.util.equals(IDPSAMLAccessInformation, a, b);
  }
}

/**
 * @generated from message zitadel.user.v3alpha.IDPAuthenticator
 */
export class IDPAuthenticator extends Message<IDPAuthenticator> {
  /**
   * ID of the identity provider
   *
   * @generated from field: string idp_id = 1;
   */
  idpId = "";

  /**
   * ID of the user provided by the identity provider
   *
   * @generated from field: string user_id = 2;
   */
  userId = "";

  /**
   * Username of the user provided by the identity provider.
   *
   * @generated from field: string user_name = 3;
   */
  userName = "";

  constructor(data?: PartialMessage<IDPAuthenticator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "zitadel.user.v3alpha.IDPAuthenticator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "idp_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "user_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IDPAuthenticator {
    return new IDPAuthenticator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IDPAuthenticator {
    return new IDPAuthenticator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IDPAuthenticator {
    return new IDPAuthenticator().fromJsonString(jsonString, options);
  }

  static equals(a: IDPAuthenticator | PlainMessage<IDPAuthenticator> | undefined, b: IDPAuthenticator | PlainMessage<IDPAuthenticator> | undefined): boolean {
    return proto3.util.equals(IDPAuthenticator, a, b);
  }
}

